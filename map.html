<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>Seattle Parks — Satellite</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <!-- MapLibre GL JS -->
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

    <link rel="stylesheet" href="css/map.css">
    <link rel="stylesheet" href="css/main.css">
</head>

<body>
    <header>
        <nav>
            <a href="index.html">Home</a>
            <a href="map.html">Map</a>
            <a href="sources.html">Sources</a>
        </nav>
    </header>

    <button id="toggle-panel">☰ Parks</button>

    <main id="container" style="display:flex; align-items:stretch;">
        <div id="side-panel">
            <h2>Seattle Green Space Finder</h2>

            <div id="pin-controls" title="Drag this pin onto the map to set a custom location">
              <div id="drop-pin" draggable="true">
                <div class="user-pin" aria-hidden="true"></div>
              </div>
              <small>Drag the pin to place it on the map. Click the pin to remove it.</small>
            </div>

            <button id="sort-btn">Sort by PMA</button>
            <button id="sort-distance-btn">Sort by Distance</button>
            <button id="buffer-btn">Buffer</button>

            <table>
                <tr>
                    <th>Park Name</th>
                    <th>PMA</th>
                    <th>Area (sq.m)</th>
                    <th class="distance-header">Distance</th>
                </tr>
            </table>
        </div>

        <div id="map" style="position:relative; flex:1; height: calc(100vh - 60px);"></div>
    </main>

    <script>
        // ----------------------------
        // MapLibre map with satellite raster tiles (Esri World Imagery)
        // ----------------------------
        const satelliteStyle = {
            version: 8,
            name: "Esri World Imagery (simple)",
            sources: {
                "esri-world-imagery": {
                    type: "raster",
                    tiles: [
                      "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
                    ],
                    tileSize: 256,
                    attribution: "Tiles © Esri"
                }
            },
            layers: [
                {
                    id: "esri-satellite",
                    type: "raster",
                    source: "esri-world-imagery",
                    minzoom: 0,
                    maxzoom: 19
                }
            ]
        };

        const map = new maplibregl.Map({
            container: 'map',
            style: satelliteStyle,
            center: [-122.335167, 47.608013],
            zoom: 11
        });

        // ----------------------------
        // App state & helpers
        // ----------------------------
        let parksData = null;
        let originalParksGeoJSON = null;

        let deviceMarker = null;
        let customPinMarker = null;
        let userLat = null, userLon = null; // cleared when unknown

        function toRad(deg) { return deg * Math.PI / 180; }
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
            // require Number.isFinite so null/undefined are not treated as valid coords
            if (![lat1, lon1, lat2, lon2].every(Number.isFinite)) return Infinity;
            const R = 6371000;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        function formatDistance(meters) {
            // return em-dash when unknown
            if (!Number.isFinite(meters)) return "—";
            if (meters < 1000) return Math.round(meters) + " m";
            return (meters / 1000).toFixed(2) + " km";
        }
        function getFeatureLonLat(feature) {
            if (!feature || !feature.geometry) return null;
            if (feature.geometry.type === "Point") return feature.geometry.coordinates;
            return null;
        }

        // ----------------------------
        // Load GeoJSON (parks & neighborhoods)
        // ----------------------------
        async function geojsonFetch() {
            try {
                const parksResp = await fetch('assets/parks.geojson');
                parksData = await parksResp.json();
                originalParksGeoJSON = JSON.parse(JSON.stringify(parksData));

                const nbhdResp = await fetch('assets/neighborhoods.geojson');
                const neighborhoods = await nbhdResp.json();

                // build table rows for parks
                const table = document.querySelector("table");
                parksData.features.forEach((feature, idx) => {
                    let row = table.insertRow(-1);
                    row.dataset.parkIndex = idx;
                    row.dataset.distanceMeters = Infinity;
                    row.insertCell(0).innerHTML = feature.properties.NAME || '';
                    row.insertCell(1).innerHTML = feature.properties.PMA || '';
                    row.insertCell(2).innerHTML = Number(feature.properties.PARKSBND_AREA || 0).toFixed(0);
                    let dcell = row.insertCell(3);
                    dcell.className = "distance-cell";
                    dcell.innerText = "—";

                    row.addEventListener('click', () => {
                        const coords = getFeatureLonLat(feature);
                        if (coords) map.flyTo({ center: coords, zoom: 15 });
                    });
                });

                map.on('load', () => {
                    if (!map.getSource('parks')) {
                        map.addSource('parks', { type: 'geojson', data: parksData });
                    }

                    if (!map.getLayer('parks-circle')) {
                        map.addLayer({
                            id: 'parks-circle',
                            type: 'circle',
                            source: 'parks',
                            paint: {
                                'circle-radius': 4,
                                'circle-color': '#114B35',
                                'circle-stroke-color': '#ffffff',
                                'circle-stroke-width': 2,
                                'circle-opacity': 0.95
                            }
                        });
                    }
                });

            } catch (err) {
                console.error("Failed to load geojson:", err);
                alert("Error loading map data. See console for details.");
            }
        }

        geojsonFetch();

        // ----------------------------
        // Update distances & table
        // ----------------------------
        function updateAllDistancesAndTable() {
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);
            rows.forEach(row => {
                const idx = parseInt(row.dataset.parkIndex, 10);
                const feat = parksData.features[idx];
                const coords = getFeatureLonLat(feat);
                let distance = Infinity;
                if (coords && coords.length >= 2 && Number.isFinite(userLat) && Number.isFinite(userLon)) {
                    distance = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                }
                row.dataset.distanceMeters = distance;
                row.cells[3].innerText = formatDistance(distance);
            });
        }

        // ----------------------------
        // Sort by PMA (kept)
        // ----------------------------
        document.getElementById("sort-btn").addEventListener("click", () => {
            const table = document.querySelector("table");
            let switching = true;
            while (switching) {
                switching = false;
                const rows = table.rows;
                for (let i = 1; i < rows.length - 1; i++) {
                    let x = parseFloat(rows[i].cells[1].innerHTML) || 0;
                    let y = parseFloat(rows[i + 1].cells[1].innerHTML) || 0;
                    if (x < y) {
                        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                        switching = true;
                        break;
                    }
                }
            }
        });

        // ----------------------------
        // Sort by Distance (prefers custom pin)
        // ----------------------------
        document.getElementById("sort-distance-btn").addEventListener("click", function () {
            if (!parksData || !parksData.features) {
                alert("Parks data is still loading — try again in a second.");
                return;
            }

            if (customPinMarker) {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndSortTable();
                map.flyTo({ center: [userLon, userLat], zoom: 14 });
                return;
            }

            if (!navigator.geolocation) {
                alert("Geolocation is not available in this browser.");
                return;
            }

            const btn = this;
            btn.disabled = true;
            btn.innerText = "Requesting location...";

            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;

                if (deviceMarker) { deviceMarker.remove(); deviceMarker = null; }
                deviceMarker = new maplibregl.Marker({ color: '#0074D9' })
                    .setLngLat([userLon, userLat])
                    .setPopup(new maplibregl.Popup({ offset: 25 }).setText('Your location'))
                    .addTo(map);

                updateAllDistancesAndSortTable();

                btn.disabled = false;
                btn.innerText = "Sort by Distance";

                map.flyTo({ center: [userLon, userLat], zoom: 14 });
                try { deviceMarker.togglePopup(); setTimeout(()=>deviceMarker.togglePopup(), 2500); } catch(e){}
            }, err => {
                btn.disabled = false;
                btn.innerText = "Sort by Distance";
                if (err.code === err.PERMISSION_DENIED) {
                    alert("Location permission denied. Can't sort by distance.");
                } else {
                    alert("Unable to get location: " + (err.message || "unknown error"));
                }
            }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
        });

        function updateAllDistancesAndSortTable() {
            updateAllDistancesAndTable();
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);
            const rowsWithDistances = rows.map(row => ({ row, distance: parseFloat(row.dataset.distanceMeters || Infinity) }));
            rowsWithDistances.sort((a,b) => a.distance - b.distance);
            for (let entry of rowsWithDistances) table.tBodies[0].appendChild(entry.row);
        }

        // ----------------------------
        // Buffer (prefers custom pin)
        // ----------------------------
        const bufferBtn = document.getElementById("buffer-btn");
        function milesToMeters(miles) { return miles * 1609.344; }
        function applyBuffer(radiusMeters) {
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);

            if (radiusMeters === null) {
                const src = map.getSource('parks');
                if (src && originalParksGeoJSON) src.setData(originalParksGeoJSON);
                rows.forEach(r => r.style.display = '');
                return;
            }

            if (!Number.isFinite(userLat) || !Number.isFinite(userLon)) {
                alert("No user location available. Click Buffer again to allow location access or place a pin.");
                return;
            }

            const filteredFeatures = [];
            rows.forEach(row => {
                const idx = parseInt(row.dataset.parkIndex, 10);
                const feat = parksData.features[idx];
                const coords = getFeatureLonLat(feat);
                let distance = Infinity;
                if (coords && coords.length >= 2) {
                    distance = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                }
                if (distance <= radiusMeters) {
                    row.style.display = '';
                    filteredFeatures.push(feat);
                } else {
                    row.style.display = 'none';
                }
            });

            const filteredGeoJSON = { type: 'FeatureCollection', features: filteredFeatures };
            const source = map.getSource('parks');
            if (source) source.setData(filteredGeoJSON);
        }

        bufferBtn.addEventListener('click', function () {
            if (customPinMarker) {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndTable();
                createBufferDropdown();
                return;
            }

            if (deviceMarker) {
                const lngLat = deviceMarker.getLngLat();
                if (lngLat) {
                    userLat = lngLat.lat;
                    userLon = lngLat.lng;
                    updateAllDistancesAndTable();
                    createBufferDropdown();
                    return;
                }
            }

            if (!navigator.geolocation) {
                alert("Geolocation is not available in this browser.");
                return;
            }

            const btn = this;
            btn.disabled = true;
            btn.innerText = "Requesting location...";

            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;

                if (deviceMarker) { deviceMarker.remove(); deviceMarker = null; }
                deviceMarker = new maplibregl.Marker({ color: '#0074D9' })
                    .setLngLat([userLon, userLat])
                    .setPopup(new maplibregl.Popup({ offset: 25 }).setText('Your location'))
                    .addTo(map);

                map.flyTo({ center: [userLon, userLat], zoom: 12 });

                updateAllDistancesAndTable();
                createBufferDropdown();

                btn.disabled = false;
                btn.innerText = "Buffer";
            }, err => {
                btn.disabled = false;
                btn.innerText = "Buffer";
                if (err.code === err.PERMISSION_DENIED) {
                    alert("Location permission denied. Buffer requires location access.");
                } else {
                    alert("Unable to get location: " + (err.message || "unknown error"));
                }
            }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
        });

        function createBufferDropdown() {
            if (document.getElementById('buffer-select')) return;
            const btn = document.getElementById('buffer-btn');
            const container = btn.parentNode;
            const sel = document.createElement('select');
            sel.id = 'buffer-select';
            sel.title = 'Choose buffer radius';
            const opts = [
                { val: 'none', text: 'None' },
                { val: '1', text: '1 mile' },
                { val: '3', text: '3 miles' },
                { val: '5', text: '5 miles' },
                { val: '10', text: '10 miles' },
                { val: '15', text: '15+ miles' }
            ];
            opts.forEach(o => {
                const option = document.createElement('option');
                option.value = o.val;
                option.innerText = o.text;
                sel.appendChild(option);
            });
            container.replaceChild(sel, btn);
            sel.addEventListener('change', function () {
                const v = sel.value;
                if (v === 'none') applyBuffer(null);
                else applyBuffer(milesToMeters(parseFloat(v)));
            });
        }

        // New helper: reset the buffer dropdown to 'none' if it exists
        function resetBufferDropdown() {
            const sel = document.getElementById('buffer-select');
            if (sel) {
                sel.value = 'none';
                // ensure the map and table reflect no buffer
                applyBuffer(null);
            }
        }

        // ----------------------------
        // NEW: Sidebar show/hide toggle behavior
        // ----------------------------
        (function setupSidebarToggle() {
            const toggleBtn = document.getElementById("toggle-panel");
            const sidePanel = document.getElementById("side-panel");
            const mapDiv = document.getElementById("map");

            // ensure main layout uses flex so map expands/shrinks (we set inline in HTML)
            // Start state: keep side-panel visible (unless external CSS hides it)
            // Clicking toggles visibility by changing display, and calls map.resize() so MapLibre repaints.
            toggleBtn.addEventListener("click", () => {
                const isHidden = window.getComputedStyle(sidePanel).display === 'none';
                if (isHidden) {
                    // show it
                    sidePanel.style.display = '';
                    // optionally animate
                    sidePanel.style.transition = 'transform 100ms, opacity 100ms';
                    sidePanel.style.opacity = '1';
                } else {
                    // hide it
                    sidePanel.style.transition = 'transform 100ms, opacity 100ms';
                    sidePanel.style.opacity = '0';
                    // set display none after transition
                    setTimeout(() => {
                        sidePanel.style.display = 'none';
                    }, 200);
                }
                // tell the map to resize so it fills the new space correctly
                try { map.resize(); } catch (e) { /* ignore */ }
            });
        })();

        // ----------------------------
        // Sidebar drag & drop pin logic (same UX as before)
        // ----------------------------
        const dropPin = document.getElementById('drop-pin');
        const mapDiv = document.getElementById('map');

        dropPin.addEventListener('click', () => {
            if (customPinMarker) { removeCustomPin(); return; }
            const center = map.getCenter();
            placeCustomPin(center.lng, center.lat);
        });

        dropPin.addEventListener('dragstart', (evt) => {
            evt.dataTransfer.setData('text/plain', 'dropping-pin');
        });

        mapDiv.addEventListener('dragover', (evt) => {
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy';
        });

        mapDiv.addEventListener('drop', (evt) => {
            evt.preventDefault();
            const dragged = evt.dataTransfer.getData('text/plain');
            if (dragged !== 'dropping-pin') return;
            const rect = mapDiv.getBoundingClientRect();
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            const lngLat = map.unproject([x, y]);
            placeCustomPin(lngLat.lng, lngLat.lat);
        });

        function placeCustomPin(lng, lat) {
            if (customPinMarker) removeCustomPin();

            const outer = document.createElement('div'); // this is what MapLibre moves
            const inner = document.createElement('div'); // this is where you style
            inner.className = 'marker-clickable';
            outer.appendChild(inner);

            customPinMarker = new maplibregl.Marker({ element: outer, draggable: true })
              .setLngLat([lng, lat])
              .addTo(map);

            userLat = lat;
            userLon = lng;

            // reset buffer and refresh distances immediate to the pin location
            applyBuffer(null);
            resetBufferDropdown();

            updateAllDistancesAndSortTable();

            outer.addEventListener('click', (ev) => {
                ev.stopPropagation();
                removeCustomPin();
            });

            customPinMarker.on('dragend', () => {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndSortTable();
            });

            map.flyTo({ center: [lng, lat], zoom: 14 });
        }

        function removeCustomPin() {
            if (!customPinMarker) return;
            try { customPinMarker.remove(); } catch(e){}
            customPinMarker = null;

            // FALLBACK: use deviceMarker's coords if we already have it
            if (deviceMarker) {
                try {
                    const pos = deviceMarker.getLngLat();
                    if (pos && Number.isFinite(pos.lat) && Number.isFinite(pos.lng)) {
                        userLat = pos.lat;
                        userLon = pos.lng;
                        map.flyTo({ center: [userLon, userLat], zoom: 14 });
                    } else {
                        userLat = userLon = null;
                    }
                } catch (e) {
                    userLat = userLon = null;
                }
            } else {
                userLat = userLon = null;
            }

            applyBuffer(null);
            resetBufferDropdown();
            updateAllDistancesAndSortTable();
        }

        // ----------------------------
        // Hover popup for parks (name + distance or em-dash)
        // ----------------------------
        const hoverPopup = new maplibregl.Popup({
            closeButton: false,
            closeOnClick: false,
            offset: 10
        });

        map.on('mouseenter', 'parks-circle', (e) => {
            map.getCanvas().style.cursor = 'pointer';
            const feature = e.features && e.features[0];
            if (!feature) return;
            const coords = getFeatureLonLat(feature);
            let html = `<strong>${feature.properties.NAME || 'Unnamed'}</strong>`;
            if (coords && coords.length >= 2) {
                if (Number.isFinite(userLat) && Number.isFinite(userLon)) {
                    const dist = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                    html += `<div style="margin-top:4px; font-size:90%;">Distance: ${formatDistance(dist)}</div>`;
                } else {
                    html += `<div style="margin-top:4px; font-size:90%;">Distance: —</div>`;
                }
            } else {
                html += `<div style="margin-top:4px; font-size:90%;">Distance: —</div>`;
            }
            if (coords) {
                hoverPopup.setLngLat(coords).setHTML(html).addTo(map);
            }
        });

        map.on('mouseleave', 'parks-circle', () => {
            map.getCanvas().style.cursor = '';
            hoverPopup.remove();
        });

        map.on('styledata', () => {
            if (map.getLayer('parks-circle')) {
                // no-op
            }
        });

    </script>
</body>
</html>
