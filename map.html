<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>Map | Seattle Green Space Finder</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <!-- MapLibre GL JS -->
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

    <link rel="stylesheet" href="css/map.css">
    <link rel="stylesheet" href="css/main.css">
</head>

<body>
    <header>
        <nav>
            <a href="index.html" class="logo">Seattle Green Space Finder</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="map.html"aria-current="page">Map</a>
                <a href="sources.html">Sources</a>
            </div>
        </nav>
    </header>

    <button id="toggle-panel">☰ Parks</button>

    <main id="container">
        <div id="side-panel">
            <h2>Seattle Green Space Finder</h2>

            <div id="pin-controls" title="Drag this pin onto the map to set a custom location">
              <div id="drop-pin" draggable="true">
                <div class="user-pin" aria-hidden="true"></div>
              </div>
              <small>Drag pin to place it on the map. Click the pin to remove it.</small>
            </div>

            <button id="sort-btn">Sort by PMA</button>
            <button id="sort-distance-btn">Sort by Distance</button>
            <button id="buffer-btn">Buffer</button>

            <table>
                <tr>
                    <th>Park Name</th>
                    <th>PMA</th>
                    <th>Area (sq.m)</th>
                    <th class="distance-header">Distance</th>
                </tr>
            </table>
        </div>

        <div id="map" style="position:relative; height: 100vh;"></div>
    </main>

    <script>
        // ----------------------------
        // MapLibre map with satellite raster tiles (Esri World Imagery)
        // ----------------------------
        const satelliteStyle = {
            version: 8,
            name: "Esri World Imagery (simple)",
            sources: {
                "esri-world-imagery": {
                    type: "raster",
                    tiles: [
                      "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
                    ],
                    tileSize: 256,
                    attribution: "Tiles © Esri"
                }
            },
            layers: [
                {
                    id: "esri-satellite",
                    type: "raster",
                    source: "esri-world-imagery",
                    minzoom: 0,
                    maxzoom: 19
                }
            ]
        };

        const map = new maplibregl.Map({
            container: 'map',
            style: satelliteStyle,
            center: [-122.335167, 47.608013],
            zoom: 11
        });

        // ----------------------------
        // App state & helpers
        // ----------------------------
        let parksData = null;
        let originalParksGeoJSON = null;

        let deviceMarker = null;
        let customPinMarker = null;
        let userLat = null, userLon = null; // cleared when unknown

        function toRad(deg) { return deg * Math.PI / 180; }
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
            // require Number.isFinite so null/undefined are not treated as valid coords
            if (![lat1, lon1, lat2, lon2].every(Number.isFinite)) return Infinity;
            const R = 6371000;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // ----------------------------
        // NEW: display distances in miles
        // ----------------------------
        function metersToMiles(meters) {
            return meters / 1609.344;
        }

        // formatDistance: convert meters -> miles string with 2 decimals; unknown -> em-dash
        function formatDistance(meters) {
            if (!Number.isFinite(meters)) return "—";
            const miles = metersToMiles(meters);
            return miles.toFixed(2) + " mi";
        }

        function getFeatureLonLat(feature) {
            if (!feature || !feature.geometry) return null;
            if (feature.geometry.type === "Point") return feature.geometry.coordinates;
            return null;
        }

        // ----------------------------
        // Load GeoJSON (parks & neighborhoods)
        // ----------------------------
        async function geojsonFetch() {
            try {
                const parksResp = await fetch('assets/parks.geojson');
                parksData = await parksResp.json();
                originalParksGeoJSON = JSON.parse(JSON.stringify(parksData));

                const nbhdResp = await fetch('assets/neighborhoods.geojson');
                const neighborhoods = await nbhdResp.json();

                // build table rows for parks
                const table = document.querySelector("table");
                parksData.features.forEach((feature, idx) => {
                    let row = table.insertRow(-1);
                    row.dataset.parkIndex = idx;

                    // --- WORKING PMA LOGIC MERGED IN ---
                    // Read text, normalize (strip commas/whitespace), parse numeric PMA
                    const pmaRaw = feature.properties && feature.properties.PMA ? String(feature.properties.PMA) : '';
                    const pmaNormalized = pmaRaw.replace(/,/g, '').trim();
                    const pmaNum = Number(pmaNormalized);
                    // store both dataset (string) and a numeric property for fast sort
                    row.dataset.pma = Number.isFinite(pmaNum) ? String(pmaNum) : String(NaN);
                    // numeric property avoids repeated Number(...) conversions later
                    row._pmaNum = Number.isFinite(pmaNum) ? pmaNum : -Infinity;
                    // --- end PMA logic ---

                    // store distance placeholder (meters)
                    row.dataset.distanceMeters = Infinity;

                    row.insertCell(0).innerHTML = feature.properties.NAME || '';
                    row.insertCell(1).innerHTML = feature.properties.PMA || '';
                    row.insertCell(2).innerHTML = Number(feature.properties.PARKSBND_AREA || 0).toFixed(0);
                    let dcell = row.insertCell(3);
                    dcell.className = "distance-cell";
                    dcell.innerText = "—";

                    row.addEventListener('click', () => {
                        const coords = getFeatureLonLat(feature);
                        if (coords) map.flyTo({ center: coords, zoom: 15 });
                    });
                });

                map.on('load', () => {
                    // add parks source and layers (circle + optional icon symbol)
                    if (!map.getSource('parks')) {
                        map.addSource('parks', { type: 'geojson', data: parksData });
                    }

                    // circle layer used to show park location (smaller, dark green, white outline)
                    if (!map.getLayer('parks-circle')) {
                        map.addLayer({
                            id: 'parks-circle',
                            type: 'circle',
                            source: 'parks',
                            paint: {
                                'circle-radius': 4,                 // smaller
                                'circle-color': '#114B35',         // dark green
                                'circle-stroke-color': '#ffffff',  // white outline
                                'circle-stroke-width': 2,
                                'circle-opacity': 0.95
                            }
                        });
                    }

                    // neighborhoods: intentionally no blue fill/haze; can add outline if desired.
                });

            } catch (err) {
                console.error("Failed to load geojson:", err);
                alert("Error loading map data. See console for details.");
            }
        }

        geojsonFetch();

        // ----------------------------
        // Update distances & table
        // ----------------------------
        function updateAllDistancesAndTable() {
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);
            rows.forEach(row => {
                const idx = parseInt(row.dataset.parkIndex, 10);
                const feat = parksData.features[idx];
                const coords = getFeatureLonLat(feat);
                let distance = Infinity;
                // use Number.isFinite to avoid coercion (null -> 0)
                if (coords && coords.length >= 2 && Number.isFinite(userLat) && Number.isFinite(userLon)) {
                    distance = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                }
                // store meters internally for logic that needs meters
                row.dataset.distanceMeters = distance;
                // display miles in UI
                row.cells[3].innerText = formatDistance(distance);
            });
        }

        // ----------------------------
        // Optimized Sort by PMA (desc)
        // ----------------------------
        document.getElementById("sort-btn").addEventListener("click", () => {
            const table = document.querySelector("table");

            // collect rows (skip header)
            const rows = Array.from(table.rows).slice(1);

            // prepare array with numeric PMA for stable and fast sorting
            const rowObjs = rows.map((row, idx) => {
                // prefer the cached numeric property, fallback to dataset parse
                const pmaNumeric = (typeof row._pmaNum === 'number') ? row._pmaNum :
                                   (Number.isFinite(Number(row.dataset.pma)) ? Number(row.dataset.pma) : -Infinity);
                return { row, pmaNumeric, idx };
            });

            // sort descending by pmaNumeric (stable via index fallback)
            rowObjs.sort((a, b) => {
                if (a.pmaNumeric > b.pmaNumeric) return -1;
                if (a.pmaNumeric < b.pmaNumeric) return 1;
                // tie-breaker: original order to keep stability
                return a.idx - b.idx;
            });

            // use DocumentFragment for minimal reflow
            const frag = document.createDocumentFragment();
            for (const obj of rowObjs) frag.appendChild(obj.row);
            // append sorted rows back into tbody (or table)
            if (table.tBodies && table.tBodies.length > 0) {
                table.tBodies[0].appendChild(frag);
            } else {
                table.appendChild(frag);
            }
        });

        // ----------------------------
        // Sort by Distance (prefers custom pin)
        // ----------------------------

        document.getElementById("sort-distance-btn").addEventListener("click", function () {
            if (!parksData || !parksData.features) {
                alert("Parks data is still loading — try again in a second.");
                return;
            }

            if (customPinMarker) {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndSortTable(); // pin path already sorts
                map.flyTo({ center: [userLon, userLat], zoom: 14 });
                return;
            }

            if (!navigator.geolocation) {
                alert("Geolocation is not available in this browser.");
                return;
           }

            const btn = this;
            btn.disabled = true;
            btn.innerText = "Requesting location...";

            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;

                if (deviceMarker) { deviceMarker.remove(); deviceMarker = null; }
                deviceMarker = new maplibregl.Marker({ color: '#0074D9' })
                    .setLngLat([userLon, userLat])
                    .setPopup(new maplibregl.Popup({ offset: 25 }).setText('Your location'))
                    .addTo(map);

                // *** Important: update distances AND sort the table ***
                updateAllDistancesAndSortTable();

                btn.disabled = false;
                btn.innerText = "Sort by Distance";

                map.flyTo({ center: [userLon, userLat], zoom: 14 });
                try { deviceMarker.togglePopup(); setTimeout(()=>deviceMarker.togglePopup(), 2500); } catch(e){}
            }, err => {
                btn.disabled = false;
                btn.innerText = "Sort by Distance";
                if (err.code === err.PERMISSION_DENIED) {
                    alert("Location permission denied. Can't sort by distance.");
                } else {
                    alert("Unable to get location: " + (err.message || "unknown error"));
                }
            }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
        });

        function updateAllDistancesAndSortTable() {
            updateAllDistancesAndTable();
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);
            const rowsWithDistances = rows.map(row => ({ row, distance: parseFloat(row.dataset.distanceMeters || Infinity) }));
            rowsWithDistances.sort((a,b) => a.distance - b.distance);
            for (let entry of rowsWithDistances) table.tBodies[0].appendChild(entry.row);
        }

        // ----------------------------
        // Buffer (prefers custom pin)
        // ----------------------------
        const bufferBtn = document.getElementById("buffer-btn");
        function milesToMeters(miles) { return miles * 1609.344; }
        function applyBuffer(radiusMeters) {
            const table = document.querySelector("table");
            const rows = Array.from(table.rows).slice(1);

            if (radiusMeters === null) {
                const src = map.getSource('parks');
                if (src && originalParksGeoJSON) src.setData(originalParksGeoJSON);
                rows.forEach(r => r.style.display = '');
                return;
            }

            if (!Number.isFinite(userLat) || !Number.isFinite(userLon)) {
                alert("No user location available. Click Buffer again to allow location access or place a pin.");
                return;
            }

            const filteredFeatures = [];
            rows.forEach(row => {
                const idx = parseInt(row.dataset.parkIndex, 10);
                const feat = parksData.features[idx];
                const coords = getFeatureLonLat(feat);
                let distance = Infinity;
                if (coords && coords.length >= 2) {
                    distance = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                }
                if (distance <= radiusMeters) {
                    row.style.display = '';
                    filteredFeatures.push(feat);
                } else {
                    row.style.display = 'none';
                }
            });

            const filteredGeoJSON = { type: 'FeatureCollection', features: filteredFeatures };
            const source = map.getSource('parks');
            if (source) source.setData(filteredGeoJSON);
        }

        bufferBtn.addEventListener('click', function () {
            if (customPinMarker) {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndTable();
                createBufferDropdown();
                return;
            }

            if (deviceMarker) {
                const lngLat = deviceMarker.getLngLat();
                if (lngLat) {
                    userLat = lngLat.lat;
                    userLon = lngLat.lng;
                    updateAllDistancesAndTable();
                    createBufferDropdown();
                    return;
                }
            }

            if (!navigator.geolocation) {
                alert("Geolocation is not available in this browser.");
                return;
            }

            const btn = this;
            btn.disabled = true;
            btn.innerText = "Requesting location...";

            navigator.geolocation.getCurrentPosition(pos => {
                userLat = pos.coords.latitude;
                userLon = pos.coords.longitude;

                if (deviceMarker) { deviceMarker.remove(); deviceMarker = null; }
                deviceMarker = new maplibregl.Marker({ color: '#0074D9' })
                    .setLngLat([userLon, userLat])
                    .setPopup(new maplibregl.Popup({ offset: 25 }).setText('Your location'))
                    .addTo(map);

                map.flyTo({ center: [userLon, userLat], zoom: 12 });

                updateAllDistancesAndTable();
                createBufferDropdown();

                btn.disabled = false;
                btn.innerText = "Buffer";
            }, err => {
                btn.disabled = false;
                btn.innerText = "Buffer";
                if (err.code === err.PERMISSION_DENIED) {
                    alert("Location permission denied. Buffer requires location access.");
                } else {
                    alert("Unable to get location: " + (err.message || "unknown error"));
                }
            }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
        });

        function createBufferDropdown() {
            if (document.getElementById('buffer-select')) return;
            const btn = document.getElementById('buffer-btn');
            const container = btn.parentNode;
            const sel = document.createElement('select');
            sel.id = 'buffer-select';
            sel.title = 'Choose buffer radius';
            const opts = [
                { val: 'none', text: 'None' },
                { val: '1', text: '1 mile' },
                { val: '3', text: '3 miles' },
                { val: '5', text: '5 miles' },
                { val: '10', text: '10 miles' },
                { val: '15', text: '15+ miles' }
            ];
            opts.forEach(o => {
                const option = document.createElement('option');
                option.value = o.val;
                option.innerText = o.text;
                sel.appendChild(option);
            });
            container.replaceChild(sel, btn);
            sel.addEventListener('change', function () {
                const v = sel.value;
                if (v === 'none') applyBuffer(null);
                else applyBuffer(milesToMeters(parseFloat(v)));
            });
        }

        // New helper: reset the buffer dropdown to 'none' if it exists
        function resetBufferDropdown() {
            const sel = document.getElementById('buffer-select');
            if (sel) {
                sel.value = 'none';
                // ensure the map and table reflect no buffer
                applyBuffer(null);
            }
        }

        // ----------------------------
        // Sidebar toggle
        // ----------------------------
        document.getElementById("toggle-panel").addEventListener("click", () => {
            document.getElementById("side-panel").classList.toggle("collapsed");
            document.getElementById("toggle-panel").classList.toggle("shifted");
        });

        // ----------------------------
        // Drag & drop pin logic (same UX as before)
        // ----------------------------
        const dropPin = document.getElementById('drop-pin');
        const mapDiv = document.getElementById('map');

        dropPin.addEventListener('click', () => {
            if (customPinMarker) { removeCustomPin(); return; }
            const center = map.getCenter();
            placeCustomPin(center.lng, center.lat);
        });

        dropPin.addEventListener('dragstart', (evt) => {
            evt.dataTransfer.setData('text/plain', 'dropping-pin');
        });

        mapDiv.addEventListener('dragover', (evt) => {
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy';
        });

        mapDiv.addEventListener('drop', (evt) => {
            evt.preventDefault();
            const dragged = evt.dataTransfer.getData('text/plain');
            if (dragged !== 'dropping-pin') return;
            const rect = mapDiv.getBoundingClientRect();
            const x = evt.clientX - rect.left;
            const y = evt.clientY - rect.top;
            const lngLat = map.unproject([x, y]);
            placeCustomPin(lngLat.lng, lngLat.lat);
        });

        function placeCustomPin(lng, lat) {
            if (customPinMarker) removeCustomPin();

            const outer = document.createElement('div'); // this is what MapLibre moves
            const inner = document.createElement('div'); // this is where you style
            inner.className = 'marker-clickable';
            outer.appendChild(inner);

            customPinMarker = new maplibregl.Marker({ element: outer, draggable: true })
              .setLngLat([lng, lat])
              .addTo(map);
            // AUTHORITATIVE: set user location to the pin immediately
            userLat = lat;
            userLon = lng;

            // reset buffer and refresh distances immediate to the pin location
            applyBuffer(null);
            resetBufferDropdown();

            updateAllDistancesAndSortTable();

            outer.addEventListener('click', (ev) => {
                ev.stopPropagation();
                removeCustomPin();
            });

            customPinMarker.on('dragend', () => {
                const lngLat = customPinMarker.getLngLat();
                userLat = lngLat.lat;
                userLon = lngLat.lng;
                updateAllDistancesAndSortTable();
            });

            map.flyTo({ center: [lng, lat], zoom: 14 });
        }

        function removeCustomPin() {
            if (!customPinMarker) return;
            try { customPinMarker.remove(); } catch(e){}
            customPinMarker = null;

            // FALLBACK: use deviceMarker's coords if we already have it
            if (deviceMarker) {
                try {
                    const pos = deviceMarker.getLngLat();
                    if (pos && Number.isFinite(pos.lat) && Number.isFinite(pos.lng)) {
                        userLat = pos.lat;
                        userLon = pos.lng;
                        map.flyTo({ center: [userLon, userLat], zoom: 14 });
                    } else {
                        userLat = userLon = null;
                    }
                } catch (e) {
                    // defensively clear if anything goes wrong
                    userLat = userLon = null;
                }
            } else {
                // no device location available -> clear user coords so table shows em-dashes
                userLat = userLon = null;
            }

            // reset buffer AND reset dropdown UI, then refresh distances
            applyBuffer(null);
            resetBufferDropdown();
            updateAllDistancesAndSortTable();
        }

        // ----------------------------
        // Hover popup for parks (name + distance or em-dash)
        // ----------------------------
        // create single popup instance that we reuse
        const hoverPopup = new maplibregl.Popup({
            closeButton: false,
            closeOnClick: false,
            offset: 10
        });

        // show popup on mouseenter on parks-circle
        map.on('mouseenter', 'parks-circle', (e) => {
            // change cursor
            map.getCanvas().style.cursor = 'pointer';

            // get first feature under mouse
            const feature = e.features && e.features[0];
            if (!feature) return;

            const coords = getFeatureLonLat(feature);
            let html = `<strong>${feature.properties.NAME || 'Unnamed'}</strong>`;

            // Always show a distance line: formatted distance if known, otherwise em-dash "—"
            if (coords && coords.length >= 2) {
                if (Number.isFinite(userLat) && Number.isFinite(userLon)) {
                    const dist = haversineDistanceMeters(userLat, userLon, coords[1], coords[0]);
                    html += `<div style="margin-top:4px; font-size:90%;">Distance: ${formatDistance(dist)}</div>`;
                } else {
                    html += `<div style="margin-top:4px; font-size:90%;">Distance: —</div>`;
                }
            } else {
                html += `<div style="margin-top:4px; font-size:90%;">Distance: —</div>`;
            }

            // place popup at the feature coordinate
            if (coords) {
                hoverPopup.setLngLat(coords).setHTML(html).addTo(map);
            }
        });

        map.on('mouseleave', 'parks-circle', () => {
            map.getCanvas().style.cursor = '';
            hoverPopup.remove();
        });

        // Ensure the parks-circle layer exists before attaching hover events.
        // If the layer isn't ready yet, listen for 'load' and attach events after source/layer creation.
        map.on('styledata', () => {
            if (map.getLayer('parks-circle')) {
                // layer exists; no-op here because we've already attached events.
            }
        });

    </script>
</body>
</html>
